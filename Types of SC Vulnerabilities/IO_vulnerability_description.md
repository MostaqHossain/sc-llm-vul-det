# **Integer Overflow/Underflow Vulnerability for Smart Contracts**

## **Overview**
An **Integer Overflow/Underflow** vulnerability occurs when arithmetic operations exceed the range of the integer type, causing unintended behavior. In Solidity, integers have fixed sizes (e.g., `uint8`, `uint256`), and exceeding their limits can cause unexpected values.

---

## **Vulnerability Detection Criteria**
A function is considered vulnerable if it meets the following conditions:

1. **ArithmeticOperation**: The function performs arithmetic operations (`+`, `-`, `*`).
2. **SafeLibraryInvocation**: The operation is **not** constrained by a safe math library.
3. **ConditionDeclaration**: The operation is **not** validated by a conditional statement (`require`, `assert`).

A function is labeled **vulnerable (`label = 1`)** if:
```
ArithmeticOperation ∧ !SafeLibraryInvocation ∧ !ConditionDeclaration
```

---

## **Examples of Vulnerable Cases**

### **1. Overflow Without Validation**
The function `add` does not check for integer overflow when adding `value` to `sellerBalance`. If `sellerBalance` is at its maximum (`255` for `uint8`), adding any number causes it to wrap around to `0`.

```solidity
contract Overflow {
    uint8 public sellerBalance = 255;
    
    function add(uint8 value) public {
        sellerBalance += value;  // No validation before addition
    }
}
```

- **Issue**: No validation before addition.
- **Risk**: An attacker can exploit this to manipulate values.
- **Label**: 1 (Vulnerable)

---

## **Examples of Safe Cases (Not Vulnerable)**

### **1. Using Safe Math Library**
The function `transfer` ensures safe arithmetic operations using the `SafeMath` library.

```solidity
library SafeMath {
    function add(uint256 a, uint256 b) internal pure returns (uint256) {
        require(a + b >= a, "Overflow");
        return a + b;
    }
}

contract SafeTransfer {
    using SafeMath for uint256;
    uint256 public balance;
    
    function deposit(uint256 amount) public {
        balance = balance.add(amount);  // Ensures safe arithmetic operations
    }
}
```

- **Fix**: Uses `SafeMath` to ensure secure arithmetic operations.
- **Label**: 0 (Safe)

---

### **2. Using Conditional Statements (`assert` or `require`)**
The function `add` uses an `assert` statement to ensure no overflow occurs.

```solidity
contract OverflowFixed {
    uint8 public sellerBalance = 0;
    
    function add(uint8 value) public {
        sellerBalance += value;
        assert(sellerBalance >= value);  // Ensures no overflow occurs
    }
}
```

- **Fix**: `assert(sellerBalance >= value);` ensures no overflow occurs.
- **Label**: 0 (Safe)

---

### **3. Using `require` for Validation**
The function `transfer` ensures the balance is sufficient before subtraction.

```solidity
contract SafeSubtraction {
    mapping(address => uint256) public balanceOf;
    
    function transfer(address to, uint256 value) public {
        require(balanceOf[msg.sender] >= value, "Insufficient balance");
        balanceOf[msg.sender] -= value;  // Prevents underflow before subtraction
        balanceOf[to] += value;
    }
}
```

- **Fix**: `require(balanceOf[msg.sender] >= value);` prevents underflow before subtraction.
- **Label**: 0 (Safe)

---

## **Summary**
A function has an **Integer Overflow/Underflow Vulnerability** if:
- It performs **arithmetic operations without validation**.  
- It does **not** use a **safe math library (`SafeMath`)**.  
- It does **not** use `require` or `assert` to check values before operations.  

A function is **Safe** if:
- It uses a **safe math library** to handle arithmetic operations securely.  
- It includes **`require` or `assert` statements** to validate conditions before execution.  
