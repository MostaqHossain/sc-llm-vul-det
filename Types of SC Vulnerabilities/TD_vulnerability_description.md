# **Timestamp Dependence Vulnerability in Smart Contracts**

## **Overview**
A **Timestamp Dependence** vulnerability occurs when a smart contract relies on `block.timestamp` to make critical decisions such as fund transfers, return values, or contract state transitions. This can be exploited because miners can manipulate timestamps slightly to influence contract behavior.

---

## **Vulnerability Detection Criteria**
A function is considered vulnerable if it meets the following conditions:

1. **TDInvocation**: The function references `block.timestamp`.
2. **TDAssign**: The timestamp is assigned to a variable that influences logic.
3. **TDContaminate**: The timestamp affects return values or financial operations.

A function is labeled as **vulnerable (****`label = 1`****)** if:
```
TDInvocation ∧ (TDAssign ∨ TDContaminate)
```

---

## **Examples of Vulnerable Cases**

### **1. Assigning `block.timestamp` to a variable (TDAssign)**
The function `setClosingTime` assigns `block.timestamp` to `closingTime`, which is then returned. This makes the function susceptible to timestamp manipulation.

```solidity
contract TimeLockedCrowdsale {
    uint256 public closingTime;       
    function setClosingTime() public returns(uint256) {
        closingTime = block.timestamp + 1;  // Vulnerable
        return closingTime;
    }
}
```
**Label: 1 (Vulnerable)**

---

### **2. Using `block.timestamp` to determine return values (TDContaminate)**
The function `determineState` returns different states based on `block.timestamp`. Since return values impact contract logic, this is considered a timestamp dependency vulnerability.

```solidity
contract TimeSensitiveCrowdsale {
    uint public startsAt;
    uint public endsAt;
    bool public finalized;
    enum State {PreFunding, Failure, Finalized}
    function determineState() public view returns (State) {
         if(finalized) return State.Finalized;
         else if (block.timestamp < startsAt) return State.PreFunding;  // Vulnerable
         else return State.Failure;
    }
}
```
**Label: 1 (Vulnerable)**

---

### **3. Using `block.timestamp` in financial operations (TDContaminate)**
The function `executeTokenRelease` uses `block.timestamp` in a `while` condition that controls token transfers. This allows timestamp manipulation to influence fund releases.

```solidity
contract TokenReleaseScheduler {
    function executeTokenRelease() public returns (uint tokens) {
         uint release;
         uint balance;
         while (release != 0 && block.timestamp > release) {  // Vulnerable
                tokens += balance;
                msg.sender.call{value: tokens}();
         }
         return tokens;
    }
}
```
**Label: 1 (Vulnerable)**

---

## **Examples of Safe Cases (Not Vulnerable)**

### **1. Timestamp used in a strict condition (TDAssign)**
The function `validateWithdrawal` assigns `block.timestamp` to a variable but only checks it inside a `require` statement. Since it does not affect logic beyond validation, it is not vulnerable.

```solidity
contract SecureTransaction {
    address public owner;
    uint256 public lock;        
    function validateWithdrawal(address to, uint value) public returns (bool) {
        require(msg.sender == owner);
        uint256 time = block.timestamp;
        require(time >= lock);  // Safe
        require(to != address(0));
        return true;
    }
}
```
**Label: 0 (Safe)**

---

### **2. Timestamp only used to trigger an exception**
The function `validateGiftClaim` checks `block.timestamp` but only throws an error if conditions are unmet. Since it does not influence return values or financial operations, it is not vulnerable.

```solidity
contract GiftClaimValidator {
    address public recipient;
    uint public birthday;
    function validateGiftClaim() public {
         if (msg.sender != recipient) revert();
         if (block.timestamp < birthday) revert();  // Safe
         if (!recipient.send(address(this).balance)) revert();
    }
}
```
**Label: 0 (Safe)**

---

## **Summary**
A function has a **Timestamp Dependence Vulnerability** if:
- `block.timestamp` **affects logic beyond validation**, such as:

- Assigning it to a variable that impacts return values.
- Using it in conditions that trigger fund transfers.

A function is **Safe** if:
- `block.timestamp` is **only used in validation** (`require`) or **to throw exceptions**.
