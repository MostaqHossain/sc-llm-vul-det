# **Denial of Service (DoS) Vulnerability in Smart Contracts**

## **Overview**
A **Denial of Service (DoS)** vulnerability occurs when an attacker intentionally **disrupts contract execution** by **exhausting resources** or **blocking access** to certain functions. This can lead to contract failures, transaction rejections, or fund losses.

---

## **Vulnerability Detection Criteria**
A function is considered vulnerable if it meets the following conditions:

1. **Resource Exhaustion**: The function can be **abused to consume excessive gas**, preventing execution.
2. **Blocking Conditions**: The function can be **manipulated to prevent other users from interacting with the contract**.
3. **External Call Dependence**: The function relies on **external contract execution**, which may fail or revert indefinitely.

A function is labeled **vulnerable (`label = 1`)** if:
```
(Resource Exhaustion ∨ Blocking Conditions ∨ External Call Dependence)
```

---

## **Examples of Vulnerable Cases**

### **1. Loop-Based Resource Exhaustion (Gas Limit Attack)**
The function **`processPayments`** processes an unbounded number of payments in a single transaction, making it vulnerable to **gas limit attacks**.

```solidity
contract DoSLoop {
    address[] public payees;
    mapping(address => uint256) public balances;
    
    function processPayments() public {
        for (uint i = 0; i < payees.length; i++) {
            require(payees[i].send(balances[payees[i]]));  // May exceed gas limit
            balances[payees[i]] = 0;
        }
    }
}
```
- **Issue**: The function **loops through an unbounded array**, consuming excessive gas.
- **Risk**: If `payees` grows too large, transactions will **fail due to gas limits**.
- **Label: 1 (Vulnerable)**

---

### **2. Blocking Critical Operations (Griefing Attack)**
The function **`bid`** allows users to bid, but does not handle cases where an external address **rejects payments**, leading to a contract lock.

```solidity
contract DoSAuction {
    address public highestBidder;
    uint256 public highestBid;

    function bid() public payable {
        require(msg.value > highestBid);
        if (highestBidder != address(0)) {
            highestBidder.transfer(highestBid);  // Can fail, blocking future bids
        }
        highestBidder = msg.sender;
        highestBid = msg.value;
    }
}
```
- **Issue**: If `highestBidder` is a contract that **rejects Ether transfers**, future bids are **blocked**.
- **Risk**: The contract is **stuck**, and no one can bid higher.
- **Label: 1 (Vulnerable)**

---

## **Examples of Safe Cases (Not Vulnerable)**

### **1. Using `pull-over-push` for Payments**
The function **`withdrawFunds`** allows users to withdraw funds instead of forcing payments.

```solidity
contract SafeAuction {
    mapping(address => uint256) public pendingReturns;

    function bid() public payable {
        require(msg.value > pendingReturns[msg.sender]);
        pendingReturns[msg.sender] += msg.value;
    }
    
    function withdrawFunds() public {
        uint256 amount = pendingReturns[msg.sender];
        pendingReturns[msg.sender] = 0;
        payable(msg.sender).transfer(amount);  // Prevents contract blocking
    }
}
```
- **Fix**: Users manually **withdraw funds** instead of forcing payments.
- **Label: 0 (Safe)**

---

## **Summary**
A function has a **Denial of Service (DoS) Vulnerability** if:
- It **contains unbounded loops**, leading to **gas exhaustion**.  
- It **relies on external calls** that may fail and **block execution**.  
- It **locks critical functions**, preventing further contract interactions.  

A function is **Safe** if:
- It **removes unbounded loops** and ensures **efficient gas usage**.  
- It **uses `pull-over-push` payment models** to prevent **contract locking**.  
- It **handles external call failures** gracefully without blocking execution.  
