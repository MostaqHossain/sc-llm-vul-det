# **Gas Limit Issues in Smart Contracts**

## **Overview**
A **Gas Limit Issue** occurs when a contract **exceeds Ethereum’s gas limit** during execution, causing transactions to fail. This can happen due to **inefficient loops, excessive computation, or deeply nested function calls**. If a contract consistently runs out of gas, it becomes **unusable** and may prevent critical operations.

---

## **Vulnerability Detection Criteria**
A function is considered vulnerable if it meets the following conditions:

1. **Unbounded Loops**: The function contains loops that **iterate over dynamic data structures** (e.g., arrays, mappings) without a termination condition.
2. **Excessive Computation**: The function performs **highly complex calculations** or **multiple external contract calls** within a single transaction.
3. **Deeply Nested Calls**: The function calls **multiple contracts in a chain**, consuming excessive gas before execution completes.

A function is labeled **vulnerable (`label = 1`)** if:
```
(Unbounded Loops ∨ Excessive Computation ∨ Deeply Nested Calls)
```

---

## **Examples of Vulnerable Cases**

### **1. Unbounded Loops Leading to Gas Exhaustion**
The function **`processAllPayments`** iterates over a growing array, consuming more gas as the array increases in size.

```solidity
contract GasExhaustion {
    address[] public payees;
    mapping(address => uint256) public balances;
    
    function processAllPayments() public {
        for (uint i = 0; i < payees.length; i++) {
            require(payees[i].send(balances[payees[i]]));  // May exceed gas limit
            balances[payees[i]] = 0;
        }
    }
}
```
- **Issue**: If `payees` grows too large, transactions will **fail due to gas limits**.
- **Risk**: Users may be unable to withdraw funds as expected.
- **Label: 1 (Vulnerable)**

---

### **2. Excessive Computation in a Single Transaction**
The function **`computeHashes`** performs a large number of hash calculations, which may exceed gas limits.

```solidity
contract HeavyComputation {
    function computeHashes(uint256 num) public pure returns (bytes32[] memory) {
        bytes32[] memory results = new bytes32[](num);
        for (uint256 i = 0; i < num; i++) {
            results[i] = keccak256(abi.encodePacked(i));  // High gas usage
        }
        return results;
    }
}
```
- **Issue**: The function runs an expensive loop with **computationally expensive hashing**.
- **Risk**: Calling the function with large values **may exceed the gas limit**, causing failure.
- **Label: 1 (Vulnerable)**

---

## **Examples of Safe Cases (Not Vulnerable)**

### **1. Using Batching to Reduce Gas Consumption**
Instead of processing all payees in one transaction, the function **`processPaymentsInBatches`** allows payments in smaller batches.

```solidity
contract SafeBatchProcessing {
    address[] public payees;
    mapping(address => uint256) public balances;
    uint256 public batchSize = 10;
    
    function processPaymentsInBatches(uint256 startIndex) public {
        uint256 endIndex = startIndex + batchSize;
        if (endIndex > payees.length) {
            endIndex = payees.length;
        }
        for (uint256 i = startIndex; i < endIndex; i++) {
            payable(payees[i]).transfer(balances[payees[i]]);
            balances[payees[i]] = 0;
        }
    }
}
```
- **Fix**: Splits execution into **smaller, manageable batches**.
- **Label: 0 (Safe)**

---

### **2. Offloading Computation to an Off-Chain Solution**
Instead of performing heavy computation on-chain, **off-chain processing** can reduce gas costs.

```solidity
contract SafeComputation {
    function submitPrecomputedHash(bytes32 hash) public pure returns (bytes32) {
        return hash;  // No on-chain computation
    }
}
```
- **Fix**: Computes data **off-chain** and submits only necessary values on-chain.
- **Label: 0 (Safe)**

---

## **Conclusion**
A function has a **Gas Limit Issue** if:
- It contains **unbounded loops** that scale with user data.  
- It performs **intensive on-chain calculations** that could be handled off-chain.  
- It makes **deeply nested external contract calls**, leading to high gas costs.  

A function is **Safe** if:
- It **splits execution into batches** to keep gas usage manageable.  
- It **processes computations off-chain**, submitting only results on-chain.  
- It **optimizes contract architecture** to reduce unnecessary gas consumption.  
