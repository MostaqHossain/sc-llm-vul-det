# **Front Running Vulnerability in Smart Contracts**

## **Overview**
A **Front Running** vulnerability occurs when an attacker **manipulates transaction ordering** to gain an unfair advantage in financial applications. This happens because transactions are visible in the **mempool** before they are included in a block, allowing malicious actors to prioritize their transactions to benefit from price changes or arbitrage opportunities.

---

## **Vulnerability Detection Criteria**
A function is considered vulnerable if it meets the following conditions:

1. **Publicly Visible Transactions**: The contract executes **critical financial transactions** that are visible in the public mempool.
2. **Time-Sensitive Execution**: The function **relies on price changes** or other dynamic values that an attacker can predict.
3. **No Front-Running Mitigation**: The function **lacks measures** such as **commit-reveal schemes, order batching, or maximum slippage protection**.

A function is labeled **vulnerable (`label = 1`)** if:
```
(Publicly Visible Transactions ∨ Time-Sensitive Execution ∨ No Front-Running Mitigation)
```

---

## **Examples of Vulnerable Cases**

### **1. Unprotected Swap Function**
The function **`swapTokens`** allows users to exchange tokens but does not include **any front-running protection**.

```solidity
contract UnprotectedSwap {
    IERC20 public tokenA;
    IERC20 public tokenB;
    uint256 public exchangeRate;
    
    function swapTokens(uint256 amount) public {
        uint256 tokensToReceive = amount * exchangeRate;
        require(tokenA.transferFrom(msg.sender, address(this), amount));
        require(tokenB.transfer(msg.sender, tokensToReceive));
    }
}
```
- **Issue**: The exchange rate can be **manipulated** before execution.
- **Risk**: Attackers can submit their own transactions with **higher gas fees** to execute trades before others, profiting unfairly.
- **Label: 1 (Vulnerable)**

---

### **2. Manipulatable Auction System**
The function **`bid`** allows users to place bids without any **commitment mechanism**, making it vulnerable to front-running.

```solidity
contract VulnerableAuction {
    uint256 public highestBid;
    address public highestBidder;

    function bid() public payable {
        require(msg.value > highestBid);
        highestBidder = msg.sender;
        highestBid = msg.value;
    }
}
```
- **Issue**: Attackers can **monitor pending transactions** and **outbid legitimate users** by submitting higher bids with higher gas fees.
- **Risk**: Fair participants may **never win the auction** due to front-running.
- **Label: 1 (Vulnerable)**

---

## **Examples of Safe Cases (Not Vulnerable)**

### **1. Using a Commit-Reveal Scheme**
Instead of placing public bids, the **commit-reveal mechanism** requires users to first submit a **hashed bid**, preventing front-running.

```solidity
contract SecureAuction {
    struct Bid {
        bytes32 commitment;
        bool revealed;
    }

    mapping(address => Bid) public bids;

    function commitBid(bytes32 _commitment) public {
        bids[msg.sender] = Bid(_commitment, false);
    }

    function revealBid(uint256 _amount, bytes32 _salt) public {
        require(!bids[msg.sender].revealed);
        require(keccak256(abi.encodePacked(_amount, _salt)) == bids[msg.sender].commitment);
        bids[msg.sender].revealed = true;
    }
}
```
- **Fix**: Users submit **hidden bids**, reducing the risk of front-running.
- **Label: 0 (Safe)**

---

### **2. Implementing Slippage Protection in Trades**
Adding **slippage tolerance** prevents users from getting unfavorable trade execution due to front-running.

```solidity
contract SecureSwap {
    IERC20 public tokenA;
    IERC20 public tokenB;
    uint256 public exchangeRate;

    function swapTokens(uint256 amount, uint256 minTokensOut) public {
        uint256 tokensToReceive = amount * exchangeRate;
        require(tokensToReceive >= minTokensOut, "Slippage limit exceeded");
        require(tokenA.transferFrom(msg.sender, address(this), amount));
        require(tokenB.transfer(msg.sender, tokensToReceive));
    }
}
```
- **Fix**: The **`minTokensOut`** parameter ensures users get a fair rate and avoid front-running losses.
- **Label: 0 (Safe)**

---

## **Summary**
A function has a **Front Running Vulnerability** if:
- It allows **publicly visible financial transactions** that can be manipulated.  
- It is **time-sensitive**, allowing attackers to **execute before others**.  
- It does not have **front-running protections** such as **commit-reveal schemes or slippage protection**.  

A function is **Safe** if:
- It **hides critical transaction details** using commit-reveal schemes.  
- It **limits front-running risks** with slippage protection.  
- It **batches transactions** to prevent priority ordering attacks.  
