# **Reentrancy Vulnerability of Smart Contracts**

## **Overview**
A **Reentrancy Vulnerability** occurs when a function sends Ether (`call.value`) before updating the user’s balance, allowing an attacker to recursively call the function and drain funds before the balance is updated.

---

## **Vulnerability Detection Criteria**
A function is considered vulnerable if it meets the following conditions:

1. **callValueInvocation**: The function uses `call.value`, which allows external calls.
2. **balanceDeduction**: The balance is **not** deducted before the money transfer.
3. **zeroParameter**: The function does **not** have a zero-value `call.value` parameter.
4. **ModifierConstrain**: The function is **not** protected by the `onlyOwner` modifier.

A function is labeled **vulnerable (`label = 1`)** if:
```
callValueInvocation ∧ !balanceDeduction ∧ !zeroParameter ∧ !ModifierConstrain
```

---

## **Examples of Vulnerable Cases**

### **1. Reentrancy Without Balance Deduction**
The function `forwardFunds` sends Ether using `call.value` **before** updating the balance. This allows an attacker to call the function multiple times before the balance is updated.

```solidity
contract ReentrancyVulnerable {
    mapping(address => uint256) balances;
    
    function withdrawFunds() public {
        require(balances[msg.sender] > 0);
        msg.sender.call{value: balances[msg.sender]}("");  // Vulnerable
        balances[msg.sender] = 0;  // Balance updated after call
    }
}
```

- **Issue**: Balance is updated **after** sending funds.
- **Risk**: An attacker can **re-enter** the function before the balance is updated.
- **Label**: 1 (Vulnerable)

---

## **Examples of Safe Cases (Not Vulnerable)**

### **1. Safe Use of `call.value` with Zero Parameter**
The function `transfer` uses `call.value(0)`, meaning no actual funds are transferred, making reentrancy impossible.

```solidity
contract SafeTransfer {
    function safeCall() public {
        msg.sender.call{value: 0}("");  // No Ether transferred
    }
}
```

- **Fix**: Uses `call.value(0)`, ensuring no unintended transfers.
- **Label**: 0 (Safe)

---

### **2. Deducting Balance Before `call.value`**
The function `withdrawFunds` properly deducts the sender's balance **before** calling `call.value`, making it safe from reentrancy.

```solidity
contract ReentrancySafe {
    mapping(address => uint256) balances;
    
    function withdrawFunds() public {
        uint256 amount = balances[msg.sender];
        require(amount > 0);
        balances[msg.sender] = 0;  // Deduct balance before transfer
        msg.sender.call{value: amount}("");
    }
}
```

- **Fix**: Balance is deducted **before** sending Ether.
- **Label**: 0 (Safe)

---

### **3. Protecting Function with `onlyOwner` Modifier**
The function `forwardFunds` is constrained by `onlyOwner`, preventing external attackers from calling it.

```solidity
contract OwnerRestricted {
    address owner;
    
    modifier onlyOwner() {
        require(msg.sender == owner);
        _;
    }
    
    function forwardFunds() public onlyOwner {
        payable(owner).transfer(address(this).balance);  // Restricted to owner
    }
}
```

- **Fix**: Only the contract **owner** can call `forwardFunds`.
- **Label**: 0 (Safe)

---

## **Summary**
A function has a **Reentrancy Vulnerability** if:
- It **sends Ether (`call.value`) before updating balances**, allowing multiple reentries.  
- It **does not check parameters** or restrict access (`onlyOwner`).  

A function is **Safe** if:
- It **deducts balances before transferring Ether**.  
- It **restricts access** using the `onlyOwner` modifier.  
- It **uses `call.value(0)`** to prevent unintended transfers.  
