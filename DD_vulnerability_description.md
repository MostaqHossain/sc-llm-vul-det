# Dangerous Delegatecall Vulnerability for Smart Contracts

## Overview
A **delegatecall** vulnerability occurs when a smart contract uses `delegatecall` without proper restrictions. Since `delegatecall` runs the callee's code in the caller’s execution context, it can lead to security risks such as **Ether loss, storage corruption, or unexpected contract behavior**.

## Vulnerability Detection Criteria
A function is considered vulnerable if it meets the following conditions:

1. **DelegateInvocation**: The function uses `delegatecall`.
2. **OwnerInvocation**: The function is not restricted to being called only by the contract owner.

A function is labeled vulnerable (`label = 1`) if:

**`DelegateInvocation ∧ !OwnerInvocation`**

---

## Examples of Vulnerable Cases

### 1. Unprotected Delegatecall
The function `forward` allows any user to call `delegatecall` with arbitrary data, which can lead to unauthorized execution and storage manipulation.

![image](https://github.com/user-attachments/assets/76da3792-113e-42a2-bed6-b6591b4c50fb)

- **Issue**: No `onlyOwner` restriction, allowing external users to exploit `delegatecall`.
- **Risk**: Attackers can manipulate contract storage or execute unintended code.
- **Label**: 1 (Vulnerable)

---

## Examples of Safe Cases (Not Vulnerable)

### 1. Restricting Delegatecall to Owner
The function `forward` ensures that only the contract owner can execute `delegatecall`, preventing unauthorized execution.

![image](https://github.com/user-attachments/assets/a4a79e78-08b2-4722-9286-3386194de041)

- **Fix**: Uses `onlyOwner` modifier (line 11) to restrict `delegatecall` execution.
- **Label**: 0 (Safe)

---

## Summary

A function has a **Dangerous Delegatecall Vulnerability** if:
- It allows any user to execute `delegatecall` without restriction.
- It lacks an owner verification mechanism (`onlyOwner`).

A function is **Safe** if:
- It restricts `delegatecall` execution to the contract owner (`onlyOwner`).
